## For Document Items
getPut=The standard {0} and {1} methods are available, but because the {2} class extends {3}, {4} and {5} can also be used. There is also three variants of {6} to check whether a value exists in an Item, iterating over either all fields, a Collection of Item names to check or an Array of Item names to check. A {7} method is available, taking a Map of values to check for in their respective Items. The method is designed to work for Text or Rich Text Items. If the Item is a multi-value field, it checks for the existence of the passed value as one of the Item values.
append=If khan mode or the Fix {0} is enabled, {1} will append to the existing Item rather than the default core API functionality of appending an additional Item with he same name.
replace=If khan mode or the Fix {0} is enabled, {1} will remove the Item. If khan mode or the Fix {2} is enabled {3} or {4} will remove all Items with that name. There is an overloaded version of {5} which allows the developer to define the Item as Summary or Non-Summary.
readers=There is an {0} method to check if reader access is enabled anywhere on the Document. The core {1} etc functionality has been overrriden to ensure setting an Item as a Readers / Authors / Names item errors if the Item is not Text. It is recommended to use autoboxing by passing {2}, {3} or {4} when setting a Readers, Authors or Names field (see Autoboxing page for more details). This will set the field as the correct type.

## For Autoboxing
autoboxMv=When setting an Item value with multiple values, historically the values have had to be added to a Vector. ODA will accept any type of Collection (List or Set) or Array and pass accordingly.
autoboxBoolean=Booleans cannot be passed directly to a {0} or {1} datasource. With ODA they can be stored directly in a Document and store as "0" or "1" (text).
autoboxNumber=Integers and Doubles are stored as normal. But according to the Help documentation, only Integers and Double are allowed. So any other number format is converted using {0}
autoboxDate=Dates get converted to a DateTime and stored. If using a date format that only has the date (e.g. {0}) or only has the time (e.g. {1}), the resulting DateTime only includes that portion.
autoboxDateTimezone=<b>Note: ALL DATE/TIMES ARE STORED AS SERVER TIMEZONE.<b> Some Java date/time formats (e.g. {0}) can include a timezone element. However, the Domino DateTime timezone property is read only. Consequently, if date/times are in a different timezone, the date/time should be converted before being passed to the API.
autoboxMisc=A variety of other types are autoboxed:
autoboxPattern=<ul><li>{0}: the {1} method is called to get the regex as a String</li>
autoboxClass=<li>{0}: the Class name is stored</li>
autoboxEnum=<li>{0}: the Enum is stored in the format "ClassName EnumName", e.g. "org.openntf.domino.ext.Session$Fixes FORCE_HEX_LOWER_CASE"</li>
autoboxFormula=<li>{0}: the Formula is stored as a String</li>
autoboxNoteCoord=<li>{0}: the NoteCoordinate is stored as a String, so basically the metaversalID</li></ul>
autoboxElse=Otherwise the vallue is stored as is. This means native Java objects can be stored into a field. The resulting object is gzipped for optimisation. Obviously the object's Class must implement Serializable. If the object's Class changes between storing and retrieving, this will cause deserialization to fail. So a good approach is to have a {0} method that converts everything to scalar values stored in a {1}, and a {2} method that converts back from the {3} to the object. This way, default behaviours for new properties can be handled.